local constants = require "constants"

go.property("scan_distance_tiles",  7)
go.property("distance_to_give_up", 12.0)
go.property("speed", 100)
go.property("power_level", 100.0)
go.property("alerted", false)

local function scan(self)
	local pos = go.get_position()
	local rot = 2 * math.asin(go.get_rotation().z)

	for angle = self.scan_angles[1], self.scan_angles[2], 0.1 do
		local ray_angle = angle - rot
		local new_y = math.cos(ray_angle) * self.projection_length
		local new_x = math.sin(ray_angle) * self.projection_length

		local new_vect = vmath.vector3(pos.x + new_x, pos.y + new_y, pos.z)

		msg.post("@render:", "draw_line", { start_point = pos, end_point = new_vect, color = vmath.vector4(0, 0, 0, 1) } )
		physics.ray_cast(pos, new_vect, self.scan_for)
	end
end

local function move_to_target(self, dt)
	if self.target_pos ~= nil then
		if vmath.length(go.get_position() - self.target_pos) <= self.distance_to_give_up then
			if self.target_pos == self.start_pos then
				self.target_pos = nil
				return
			else
				self.target_pos = self.start_pos
				self.alerted = false
			end
		end

		local pos = go.get_position()
		local target_angle = -math.atan2(self.target_pos.x - pos.x, self.target_pos.y - pos.y)
		local target_quat = vmath.quat_rotation_z(target_angle)
		local current_quat = go.get_rotation()

		local q = vmath.slerp(0.08, current_quat, target_quat)
		go.set_rotation(q)
		
		-- move towards target
		local d = vmath.rotate(q, vmath.vector3(0, 1, 0))
		go.set_position(pos + d * self.speed * dt)
	end
end

function init(self)
	self.projection_length = constants.TILE_SIZE * self.scan_distance_tiles
	self.scan_angles =  {-math.pi / 6, math.pi / 6}
	self.scan_for = {hash("robot"), hash("wall"), hash("player")}
	self.target_pos = nil
	self.start_pos = go.get_position()
	self.alerted = false
	self.siphoned = false
	msg.post("circle", "disable")

	-- msg.post("/ai/robot", constants.LISTEN_ROBOT_COLLISION)
end

function update(self, dt)
	if self.power_level <= 50 then
		go.delete()
	else
		if self.siphoned ~= true then
			scan(self)
			move_to_target(self, dt)
		end

		if self.alerted and self.siphoned ~= true then
			msg.post("circle", "enable")
		else
			msg.post("circle", "disable")
		end
	end
	self.siphoned = false
end

function on_message(self, message_id, message, sender)
    if message_id == hash("ray_cast_response") and message.group == hash("player") then
        self.target_pos = message.position
		self.alerted = true
    elseif message_id == hash(constants.PLAYER_SIPHON) then
		self.siphoned = true
    elseif message_id == hash("contact_point_response") then
		if message.group == hash("wall") then
			go.set_position(go.get_position() + message.normal * message.distance)
		end
	end
end
