local constants = require "constants"

go.property("alerted_scan_distance_tiles",  9)
go.property("scan_distance_tiles",  4)
go.property("distance_to_give_up", 12.0)
go.property("speed", 100)
go.property("power_level", 100.0)
go.property("alert_level", 0.0)
go.property("minimum_circle_scale", 0.5)
go.property("siphon_drain_rate", 30.0)
go.property("patrol_end_pos", vmath.vector3(0,0,0))

local function scan(self)
	local pos = go.get_position()
	local rot = 2 * math.asin(go.get_rotation().z)

	for angle = self.scan_angles[1], self.scan_angles[2], 0.1 do
		local ray_angle = angle - rot
		local scan_distance = self.scan_distance_tiles
		if self.alert_level > 0.0 then
			scan_distance = self.alerted_scan_distance_tiles
		end
		local projection_length = constants.TILE_SIZE * scan_distance
		local new_y = math.cos(ray_angle) * projection_length
		local new_x = math.sin(ray_angle) * projection_length

		local new_vect = vmath.vector3(pos.x + new_x, pos.y + new_y, pos.z)

		msg.post("@render:", "draw_line", { start_point = pos, end_point = new_vect, color = vmath.vector4(0, 0, 0, 1) } )
		physics.ray_cast(pos, new_vect, self.scan_for)
	end
end

local function move_to_target(self, dt)
	if self.target_pos ~= nil then
		local pos = go.get_position()
		local target_angle = -math.atan2(self.target_pos.x - pos.x, self.target_pos.y - pos.y)
		local target_quat = vmath.quat_rotation_z(target_angle)
		local current_quat = go.get_rotation()

		local q = vmath.slerp(0.08, current_quat, target_quat)
		go.set_rotation(q)
		
		-- move towards target
		local d = vmath.rotate(q, vmath.vector3(0, 1, 0))
		go.set_position(pos + d * self.speed * dt)
	end
end

local function set_siphon_size(self)
	local scale = (self.power_level / 100) * self.power_circle_start_scale.x
	local scale_vect = vmath.vector3(scale, scale, scale)
	local lerped_vect = vmath.lerp(self.power_level / 100, self.min_scale_circle_vect, self.power_circle_start_scale)
	go.set_scale(lerped_vect, "circle")
end

local function siphon_from_player(self, dt)
	local player_pos = go.get_position("/player/player")
	local dist_to_player = vmath.length(go.get_position() - player_pos)
	local circle_size = go.get("circle#circle", "size")
	local circle_scale = go.get_scale("circle").x / self.power_circle_start_scale.x
	local circle_factor = circle_size.x * circle_scale
	if dist_to_player <= circle_factor then
		local player_url = msg.url(nil, "/player/player", "player_power")
		local player_power = go.get(player_url, "power_level")

		if player_power > 0 then
			go.set(player_url, "power_level", player_power - (self.siphon_drain_rate *dt))
			self.power_level = self.power_level +  (self.siphon_drain_rate *dt)
		end
	end
end

local function update_power_level(self, dt)
	self.alert_level = self.alert_level + (self.alert_rate * dt)
	if self.alert_level < 0.0 then
		self.alert_level = 0.0
	elseif self.alert_level > 100.0 then
		self.alert_level = 100.0
	end
end

local function update_target_pos(self)
	if self.alert_level == 0.0 then
		self.alerted = false
		
		if self.target_pos ~= nil then
			local dist_to_target = vmath.length(go.get_position() - self.target_pos)
			if self.does_patrol then
				if self.target_pos == self.start_pos and dist_to_target <= self.distance_to_give_up then
					self.target_pos = self.patrol_end_pos
				elseif self.target_pos == self.patrol_end_pos and dist_to_target <= self.distance_to_give_up then
					self.target_pos = self.start_pos
				elseif self.target_pos ~= self.patrol_end_pos then
					self.target_pos = self.start_pos
				end
			else
				if self.target_pos == self.start_pos and dist_to_target <= self.distance_to_give_up then
					self.target_pos = nil
				else
					self.target_pos = self.start_pos
				end
			end
		end
	end
end

local function update_siphon(self, dt)
	if (self.alerted or self.alert_level > 0.0) and self.siphoned ~= true then
		set_siphon_size(self)
		msg.post("circle", "enable")

		siphon_from_player(self, dt)
	else
		msg.post("circle", "disable")
	end
end

function init(self)
	self.scan_angles =  {-math.pi / 6, math.pi / 6}
	self.scan_for = {hash(constants.ROBOT), hash(constants.WALL), hash(constants.PLAYER)}
	self.start_pos = go.get_position()
	self.siphoned = false
	self.power_circle_start_scale = go.get_scale("circle")
	self.min_scale_circle_vect = vmath.vector3(self.minimum_circle_scale, self.minimum_circle_scale, self.minimum_circle_scale)
	self.alert_level = 0.0
	self.alert_increase_rate = 30.0
	self.alert_decrease_rate = -20.0
	self.alert_rate = self.alert_decrease_rate
	self.does_patrol =self.patrol_end_pos ~= vmath.vector3(0,0,0)
	self.target_pos = nil
	if self.does_patrol then
		self.target_pos = self.patrol_end_pos
	end
	msg.post("circle", "disable")
end

function update(self, dt)

	if self.siphoned ~= true then
		scan(self)
		move_to_target(self, dt)
	end

	update_power_level(self, dt)
	update_target_pos(self)

	update_siphon(self, dt)

	--temporary
	if self.power_level <= 0.0 then
		go.delete()
	end

	self.alert_rate = self.alert_decrease_rate
	self.siphoned = false
end

function on_message(self, message_id, message, sender)
    if message_id == hash("ray_cast_response") and message.group == hash(constants.PLAYER) then
        self.target_pos = message.position
		self.alert_rate = self.alert_increase_rate
    elseif message_id == hash(constants.PLAYER_SIPHON) then
		self.siphoned = true
    elseif message_id == hash("contact_point_response") then
		if message.group == hash(constants.WALL) or message.group == hash(constants.ROBOT) or message.group == hash(constants.PLAYER) then
			go.set_position(go.get_position() + message.normal * message.distance)
			if message.group == hash(constants.PLAYER) and not self.siphoned then
				self.target_pos = message.position
				self.alert_rate = self.alert_increase_rate
			end
		end
	end
end
